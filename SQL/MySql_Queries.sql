create DATABASE if not exists GFG_FT_B2;

USE GFG_FT_B2;

CREATE TABLE EMPLOYEE(
EMP_ID INT(10) NOT NULL UNIQUE,
FIRST_NAME VARCHAR(20) NOT NULL,
LAST_NAME varchar(20),
AGE INT(10) NOT NULL CHECK (AGE>'18'),
SALARY FLOAT(19) NOT NULL CHECK(SALARY>0)
);

SELECT * FROM EMPLOYEE;

INSERT INTO EMPLOYEE() VALUES
(1, 'GIRISH','JHARKULAE',21,340000);

INSERT INTO EMPLOYEE() VALUES
(2, 'HARISH','GULATI',22,94000),
(3, 'SONAM','TRIPATHI',19,194000),
(4, 'PRATYUSH','ISANIYA',41,84000),
(5, 'MRINAL','TOMAR',31,296000),
(6, 'MUKTHA','',23,594000);

INSERT INTO EMPLOYEE() VALUES
(7, 'VARUN','SHARMA',34,74000);

-- ALTER THE TABLE

ALTER TABLE EMPLOYEE
ADD COLUMN GENDER varchar(11);

ALTER TABLE EMPLOYEE
ADD COLUMN LOCATION varchar(11) NOT NULL;

UPDATE EMPLOYEE
SET GENDER ='FEMALE'
WHERE EMP_ID IN (1,3,5,7);

-- MODIFYING THE CONSTRAINT IN A TABLE
SELECT * FROM EMPLOYEE;


ALTER TABLE EMPLOYEE
MODIFY LAST_NAME VARCHAR(11) NOT NULL;

UPDATE EMPLOYEE
SET LAST_NAME ='GHORPADE'
WHERE EMP_ID = 7;

-- UPDATING THE SALARY VIA 35%FOR EACH EMPLOYEE
-- USING ALIAS METHOD
SELECT EMP_ID,FIRST_NAME,SALARY,
     SALARY*1.35 as updated_salary
     FROM EMPLOYEE;
     
-- LEARNING OPERATORS IN SQL
-- ORDER OF EXECUTION
SELECT * -- LAST
FROM EMPLOYEE  -- 01
WHERE EMP_ID =2; -- 02

SELECT *
FROM EMPLOYEE
WHERE EMP_ID NOT IN (2,4,6)
ORDER BY SALARY DESC;

SELECT *
FROM EMPLOYEE
WHERE EMP_ID NOT IN (2,4,6)
ORDER BY AGE DESC, SALARY DESC;
	
    
 UPDATE EMPLOYEE
SET SALARY = 85000
WHERE EMP_ID = 7;

SELECT *
FROM EMPLOYEE
WHERE EMP_ID NOT IN (2,4,6)
ORDER BY AGE DESC, SALARY DESC;

select first_name, salary, age
from employee
where age<34;

-- USE SQL_HR

USE SQL_HR;

SELECT *
FROM EMPLOYEES;

SELECT * FROM EMPLOYEES_NEW;

SELECT * FROM OFFICES;

-- EXERCISE: GET THE OFFICE IDS FOR THE CLIENTS LIVING IN OHIO,NEW YORK AND GALA

SELECT OFFICE_ID, STATE
FROM OFFICES
WHERE STATE IN ('OH','GA','NY')
ORDER BY STATE;

SELECT OFFICE_ID, STATE
FROM OFFICES
WHERE STATE  <>'VA'
ORDER BY STATE;

-- Use sql store;

USE SQL_STORE;
select * FROM CUSTOMERS;

SELECT *
FROM CUSTOMERS
WHERE BIRTH_DATE > '1973-01-01'  -- 'YYYY-MM-DD'
ORDER BY BIRTH_DATE;

SELECT *
FROM CUSTOMERS
WHERE BIRTH_DATE > '1973-01-01' AND POINTS>3000
ORDER BY BIRTH_DATE;


ALTER TABLE CUSTOMERS
ADD COLUMN MEMBERSHIP VARCHAR(10);

SET SQL_SAFE_UPDATES =0; -- DISABLES SAFE UPDATES(TEMPORARILY FOR THE SESSION)
UPDATE CUSTOMERS 
SET MEMBERSHIP = 'GOLD'
WHERE BIRTH_DATE > '1973-01-01' AND POINTS>3000;

SELECT *
FROM CUSTOMERS
WHERE BIRTH_DATE > '1985-12-31' OR (POINTS>1500 AND STATE = 'OH');

--1. HOMEWORK EXERCISE PLEASE ADD A COLUMN [MEMBERSHIP] INDICATING THESE CUSTOMER AS YOUR GOLD CUSTOMER 
--2. FIND THE CUSTOMERS WITH EITHER BEYOND THE BIRTHDATE 1985 OR WHO HAVE ATTAIN 1500 POINTS IN THE STATE OF OHIO

-- USING BETWEEN OPERATOR

USE SQL_STORE;
SELECT *
FROM CUSTOMERS
WHERE POINTS>=1101 AND POINTS <=3033;

SELECT *
FROM CUSTOMERS
WHERE POINTS BETWEEN 1101 AND 3033;

-- EXERCISE : FILTER THE CUSTOMER DATA FOR THOSE BORN BETWEEN 1990 AND 2000

SELECT *
FROM CUSTOMERS
WHERE BIRTH_DATE BETWEEN '1990-01-01' AND '2000-12-31';

-- IMPLEMENTING LIKE OPERATOR

SELECT *
FROM CUSTOMERS
WHERE LAST_NAME LIKE 'B%'; 

SELECT *
FROM CUSTOMERS
WHERE LAST_NAME LIKE '%B%';

SELECT *
FROM CUSTOMERS
WHERE PHONE LIKE '%231%';

-- EXERCISE: GET THE CUSTOMERS WHOSE ADRESS CONTAINS CAFE OR WIDDEL OR TERRACE 

SELECT *
FROM CUSTOMERS 
WHERE ADDRESS LIKE '%CIRCLE%' OR ADDRESS LIKE '%JUNCTION%' OR ADDRESS LIKE '%TERRACE%';

SELECT *
FROM CUSTOMERS 
WHERE ADDRESS NOT LIKE '%CIRCLE%' AND ADDRESS NOT LIKE '%JUNCTION%' AND ADDRESS NOT LIKE '%TERRACE%';

-- IMPLEMENTING NULL OPERATOR

SELECT * FROM CUSTOMERS
WHERE PHONE IS NULL;

SELECT * FROM CUSTOMERS
WHERE PHONE IS NOT NULL;

SELECT * FROM ORDERS
WHERE COMMENTS IS NOT NULL;

SELECT * FROM CUSTOMERS
ORDER BY 1 DESC;

-- EXERCISE: USE SQL_STORE DATABASE AND ORDER_ITEMS TABLE TO CALCULATE 
-- THE TOTAL PRICE FOR ORDER_ID AND DISPLAY THE RESULTS IN DESC ORDER

SELECT * FROM ORDER_ITEMS;


SELECT * ,QUANTITY*UNIT_PRICE AS TOTAL_PRICE
FROM ORDER_ITEMS
WHERE ORDER_ID =2;

-- IMPLEMENTING LIMIT CLAUSE 

SELECT *
FROM CUSTOMERS
WHERE CUSTOMER_ID IN (2,4,6,810)
ORDER BY POINTS DESC
LIMIT 3;

-- GROUP BY CLAUSE
SELECT * FROM ORDER_ITEMS; 

SELECT SUM(QUANTITY)
FROM ORDER_ITEMS;

SELECT SUM(QUANTITY),COUNT(*),MAX(QUANTITY),MIN(UNIT_PRICE)
FROM ORDER_ITEMS;

SELECT ORDER_ID, SUM(QUANTITY)
FROM ORDER_ITEMS
GROUP BY ORDER_ID;

-- Implementing sub queries USING WHERE STATEMENT
USE SQL_STORE;
SELECT * FROM ORDERS;
select * FROM CUSTOMERS;

select *
FROM ORDERS
WHERE CUSTOMER_ID IN ( SELECT CUSTOMER_ID FROM CUSTOMERS 
        WHERE STATE IN ('VA','TX','IL') 
		);

-- IMPLEMENT SUB QUERY USING UPDATE STATEMENT
USE SQL_INVOICING;
SELECT * FROM INVOICES;
SELECT * FROM CLIENTS;

SELECT * 
FROM SQL_INVOICING.INVOICES;

UPDATE INVOICES
SET 
	PAYMENT_TOTAL = INVOICE_TOTAL,
    PAYMENT_DATE = DUE_DATE
    
WHERE CLIENT_ID = 
					(SELECT CLIENT_ID
                    FROM CLIENTS
                    WHERE NAME = 'VINTE'
                    );
                    
-- EXERCISE: UPDATE THE PAYMENT METHOD FOR MR.'YADEL' AS "CASH"                    
   
   UPDATE PAYMENT_METHODS
SET 
	NAME = 'CASH'
WHERE PAYMENT_METHOD_ID = (SELECT CLIENT_ID
						   FROM CLIENTS
                           WHERE CLIENT_ID IN (SELECT CLIENT_ID
											   FROM CLIENTS
                                               WHERE NAME='YADEL')
                          );
                          
SELECT * FROM PAYMENT_METHODS;                           

UPDATE PAYMENT_METHODS
SET 
	NAME = 'PAYPAL'
WHERE PAYMENT_METHOD_ID = (SELECT CLIENT_ID
						   FROM CLIENTS
                           WHERE CLIENT_ID IN (SELECT CLIENT_ID
											   FROM CLIENTS
                                               WHERE NAME='YADEL')
                          );
                          
 UPDATE INVOICES
SET 
	PAYMENT_TOTAL = 0.5*INVOICE_TOTAL,
WHERE CLIENT_ID IN
					(SELECT CLIENT_ID
                    FROM CLIENTS
                    WHERE STATE IN ('CA','NY')
                    );   
                    
-- WAQ TO UPDATE THE RECORD OF ORDERS TABLE OF THE SQL_STORE
-- MARK CUSTOMERS HAVING MORE THAN 3000 POINTS AS "GOLD CUSTOMER"

SELECT * FROM sql_store.ORDERS;

UPDATE ORDERS
SET COMMENTS = 'GOLD CUSTOMER'

WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID
					  FROM CUSTOMERS
					  WHERE POINTS >=3000);
                      
-- IMPLEMENTING SUBQUERY TO COMPARE THE AVERAGE ORDER PRICE
-- OF EACH INDIVIDUAL ORDER_ID WITH THAT OF OVERALL 
-- AVERAGE PRICE WITH RESPECT TO ALL THE ORDERS 

SELECT * FROM ORDERS;

SELECT ORDER_ID, AVG(UNIT_PRICE),(SELECT AVG(UNIT_PRICE) 
								  FROM order_items) AS OVERALL_AVG
from order_items                                  
GROUP BY ORDER_ID;
                     
SELECT AVG(UNIT_PRICE) 
FROM order_items
-- GROUP BY ORDER_ID;

-- IMPLEMENTING JOINS

SELECT *
FROM ORDERS
INNER JOIN CUSTOMERS 
ON ORDERS.CUSTOMER_ID = CUSTOMERS.CUSTOMER_ID;


SELECT *
FROM ORDERS AS O
INNER JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID;


SELECT FIRST_NAME,ORDER_ID,SHIPPER_ID,O.CUSTOMER_ID,COMMENTS
FROM ORDERS AS O
INNER JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID; 


-- EXERCISE; WAQ TO JOIN THE ORDER_ITEMS TABLE WITH THE PRODUCTS TABLE 
-- ON THE PRODUCT_ID COLUMN AND SELECT THE SPECIFIC COLUMN OF YOUR CHOICE 

SELECT *
FROM ORDER_ITEMS AS OI
INNER JOIN PRODUCTS AS P
ON P.PRODUCT_ID = OI.PRODUCT_ID;


-- IMPLEMENTING THE LEFT JOIN

SELECT *
FROM PRODUCTS AS P 
LEFT JOIN ORDER_ITEMS AS O 
ON P.PRODUCT_ID = O.PRODUCT_ID;


-- IMPLEMENTING RIGHT JOIN

SELECT *
FROM order_items AS O 
RIGHT JOIN PRODUCTS AS P 
ON P.PRODUCT_ID = O.PRODUCT_ID;


-- IMPLEMENT OUTER JOIN
SELECT *
FROM order_items AS O 
RIGHT OUTER JOIN PRODUCTS AS P 
ON P.PRODUCT_ID = O.PRODUCT_ID; 

SELECT *
FROM ORDERS
LEFT OUTER JOIN SHIPPERS -- LEFT OUTER JOIN AND OUTER JOIN FETCHING THE SAME RESULTS
ON ORDERS.SHIPPER_ID = SHIPPERS.SHIPPER_ID;

-- CHECKING WITH UNIONS AS A SUBSTITUTE WRT OUTER JOIN

SELECT *
FROM ORDERS
LEFT JOIN SHIPPERS 
ON ORDERS.SHIPPER_ID = SHIPPERS.SHIPPER_ID

UNION ALL 

SELECT *
FROM ORDERS
RIGHT JOIN SHIPPERS 
ON ORDERS.SHIPPER_ID = SHIPPERS.SHIPPER_ID; 



SELECT *
FROM PRODUCTS AS P 
LEFT JOIN ORDER_ITEMS AS O 
ON P.PRODUCT_ID > O.PRODUCT_ID -- DECIPHER THE OUTPUT AND CONCLUDE YOUR LEARNING
ORDER BY O.PRODUCT_ID;

-- JOINING ACROSS DATABASES

SELECT *
FROM SQL_STORE.ORDER_ITEMS AS OI
JOIN sql_inventory.PRODUCTS AS P
ON OI.PRODUCT_ID = P.PRODUCT_ID;

-- IMPLEMENT JOINS WITH MULTIPLE TABLES

SELECT *
FROM ORDERS AS O
INNER JOIN CUSTOMERS AS C
ON O.CUSTOMER_ID = C.CUSTOMER_ID  

INNER JOIN order_statuses AS OS
ON O.STATUS = OS.order_status_id;

-- THE "USING" CLAUSE

SELECT *
FROM CUSTOMERS AS C 
LEFT JOIN ORDERS AS O
-- ON C.CUSTOMER_ID = O.CUSTOMER_ID;               
USING(CUSTOMER_ID)
RIGHT JOIN SHIPPERS AS SH 
USING (SHIPPER_ID);


-- JOINING MULTIPLE COLUMNS VIA "USING" CLAUSE

SELECT *
FROM order_items AS OI
JOIN order_item_notes AS OIN
ON OI.ORDER_ID = OIN.order_Id
AND OI.product_id = OIN.product_id;

SELECT *
FROM order_items AS OI
JOIN order_item_notes AS OIN
-- ON OI.ORDER_ID = OIN.order_Id
-- AND OI.product_id = OIN.product_id;
USING(ORDER_ID, PRODUCT_ID);

-- QUERY QUESTION
-- USE SQL_INVOICING TO CHECK THE PAYMENT METHOD ADOPTED BY THE CLIENT FOR THE GIVEN 
--  PAYMENT_ID .ALSO CHECK THE LOCATION OF ORDER BOOKING.alter

SELECT CLIENTS.NAME,PM.NAME,P.CLIENT_ID,P.payment_id, CLIENTS.STATE
FROM payment_methods AS PM
JOIN payments AS P
ON PM.payment_method_id = P.payment_method
JOIN CLIENTS 
USING(CLIENT_ID)
ORDER BY client_id;

-- IMPLEMENTING CROSS JOINS
USE SQL_STORE;

SELECT *
FROM ORDERS
CROSS JOIN CUSTOMERS
ORDER BY ORDER_ID;


-- Implementing PAIN OF SUBQUERY

-- Q- Find the stores whose sales are better than the average sales across all the stores

SELECT * FROM ORDER_ITEMS;
-- solution 1 -- finding total sales
ALTER TABLE order_items
ADD COLUMN TOTAL_SALES varchar(20);

SET SQL_SAFE_UPDATES = 0;
UPDATE order_items
SET TOTAL_SALES = UNIT_pRICE * qUANTITY;

SELECT ORDER_ID, SUM(TOTAL_SALES) AS TSPO -- THIS IS FOR TOTAL SALES
FROM order_items
GROUP BY ORDER_ID;
-- solution 2 -- finding average sales 
SELECT avg(TSPO) AS AVERAGE_SALES
FROM (SELECT ORDER_ID, SUM(TOTAL_SALES) AS TSPO 
      FROM order_items
      GROUP BY ORDER_ID
      ) AS AVERAGE_SALES_ACROSS; -- FOR FINDING AVERAGE 
-- solution 3 -- finding stores having sales above the average sales       
SELECT * 
FROM (SELECT ORDER_ID, SUM(TOTAL_SALES) AS TSPO -- THIS IS FOR TOTAL SALES
      FROM order_items
      GROUP BY ORDER_ID
      ) AS TOTAL_SALES
JOIN       
      (SELECT avg(TSPO) AS AVG_SALES
      FROM (SELECT ORDER_ID, SUM(TOTAL_SALES) AS TSPO 
      FROM order_items
      GROUP BY ORDER_ID
      ) AS TOTAL_SALES 
	) AS AVERAGE_SALES_ACROSS
ON 
   AVG_SALES < TSPO;
   
SELECT *
FROM T1
JOIN T2
ON T1.C1 = T2.C1;

-- USING CTE AND ALLEVIATING THE SUBQUERY
-- CTE [COMMON TABLE EXPRESSION]
   
SELECT * FROM ORDER_ITEMS;

WITH TOTAL_ORDERS(ORDER_ID, TOTAL_ORDERS_PER_CUSTOMER) AS
     (SELECT ORDER_ID, COUNT(*) AS TOTAL_ORDERS_PER_CUSTOMER
     FROM ORDER_ITEMS
     GROUP BY ORDER_ID
     ),
     AVG_ORDERS(A_O_P_C) AS
     (SELECT AVG(TOTAL_ORDERS_PER_CUSTOMER) AS A_O_P_C
     FROM TOTAL_ORDERS
     )
SELECT * FROM TOTAL_ORDERS AS T
JOIN AVG_ORDERS AS A
ON T.TOTAL_ORDERS_PER_CUSTOMER > A.A_O_P_C;

-- CASE STATEMENTS 

SELECT * FROM EMPLOYEES;

SELECT EMPLOYEE_ID, SALARY,
(CASE  
   WHEN SALARY > 100000 THEN 'hIGHLY PAID EMPLOYEE'
   WHEN SALARY > 50000 THEN 'AVERAGE PAID EMPLOYEE'
   ELSE 'STARTING CAREER'
END) AS PAY_SCALE
FROM EMPLOYEES; 

 SELECT FIRST_NAME, SALARY,
(CASE  
   WHEN SALARY > 100000 THEN 'hIGHLY PAID EMPLOYEE'
   WHEN SALARY > 50000 THEN 'AVERAGE PAID EMPLOYEE'
   ELSE 'STARTING CAREER'
END) AS PAY_SCALE
FROM EMPLOYEES; 

SELECT CUSTOMER_ID,POINTS
(CASE POINTS
     WHEN 3000 THEN 'PLATINUM'
     WHEN 1500 THEN 'GOLD'
     ELSE 'SILVER'
END) AS CUSTOMER_STATUS 
FROM  CUSTOMERS; 
     

CREATE TABLE SALES(
ID INT(10) NOT NULL UNIQUE,
EMPLOYEE VARCHAR(20) NOT NULL,
REGION varchar(20),
AMOUNT DECIMAL(10,2) NOT NULL,
SALES_DATE DATE
);

SELECT* FROM SALES;

INSERT INTO SALES VALUES
(1, 'MOHIT','NORTH',200,'2025-09-08'),
(2, 'SNEHA','EAST',180,'2025-09-08'),
(3, 'SONAM','SOUTH',190,'2025-09-08'),
(4, 'MEET','NORTH',300,'2025-09-08'),
(5, 'HARSH','WEST',100,'2025-09-08'),
(6, 'MEET','NORTH',1000,'2025-09-05');

-- USING WINDOW FUNCTION--
-- A WINDOW FUNCTION PERFORMS CALCULATION ACROSS A SET OF ROWS THAT ARE RELATED TO THE 
--  CURRENT ROWS , BUT WITHOUT COLLAPSING THEM INTO A SINGLE ROW

SELECT * FROM SALES;

-- Q1 GIVE EACH EMPLOYEE'S SALE A UNIQUE RANK WITHIN THEIR REGION , HIGHEST SALE FIRST

SELECT EMPLOYEE, REGION, AMOUNT,
      ROW_NUMBER()
      OVER(PARTITION BY REGION 
           ORDER BY AMOUNT DESC
		   ) AS UNIQUE_RANK
FROM SALES;

-- Q2. PROVIDE THE RANK TO THE PREVIOUS OUTPUT VIA RANK() FUNCTION 
-- AND DENSE_RANK() FUNCTION

INSERT INTO SALES VALUES
(7, 'HARSH','WEST',100,'2025-09-08');
DELETE FROM employees
WHERE employee_id = 7 and 8;

select employee,REGION,AMOUNT,
        RANK() OVER (PARTITION BY REGION 
                     ORDER BY AMOUNT DESC) AS RANK_POSITION,
		DENSE_RANK() OVER (PARTITION BY REGION 
                     ORDER BY AMOUNT DESC) AS DENSE_RANK_POSITION
FROM SALES;                     
           
-- Q3. TRACK EACH EMPLOYEE'S CUMULATIVE SALES OVER TIME
-- AS A RUNNING TOTAL	

SELECT EMPLOYEE, SALES_DATE,AMOUNT,
         SUM(AMOUNT) OVER(PARTITION BY employee
                     ORDER BY SALES_DATE) AS RUNNING_TOTAL
FROM SALES;                     

SELECT s1.id,
       s1.saleS_date,
       SUM(s2.amount) AS cumulative_sales
FROM sales s1
JOIN sales s2
  ON s1.id = s2.id
 AND s2.saleS_date <= s1.saleS_date
GROUP BY s1.id, s1.saleS_date
ORDER BY s1.id, s1.saleS_date;

-- Q4. CALCULATE THE AVERAGE OF PREVIOUS ,CURRENT AND NEXT 
-- SALE FOR EACH EMPLOYEE	

SELECT EMPLOYEE, SALES_DATE,AMOUNT,
         AVG(AMOUNT) OVER(PARTITION BY EMPLOYEE
						  ORDER BY SALES_DATE 
						  ROWS BETWEEN 1 preceding AND 1 following
                     ) AS MOVING_AVERAGE 
FROM SALES;     


SELECT EMPLOYEE, SALES_DATE,AMOUNT,
         AVG(AMOUNT) OVER(PARTITION BY EMPLOYEE
						  ORDER BY SALES_DATE 
						  ROWS BETWEEN 1 preceding AND 2 following
                     ) AS MOVING_AVERAGE 
FROM SALES; 

-- Q5. SHOW WHERE A ROW LIES RELATIVE TO OTHERS IN THE PARTITION [PERCENT RANK]

SELECT EMPLOYEE,REGION,AMOUNT,
            PERCENT_RANK() OVER (PARTITION BY REGION
                                 ORDER BY AMOUNT) AS PCT_RANK
FROM SALES;

-- KEY DIFFERENCE BETWEEN GROUP BY AND WINDOW FUNCTION
-- GROUP BY --> COLLAPSES ROWS INTO ONE SINGLE RESULT PER GROUP
-- WINDOW FUNCTION --> KEEP ALL ROWS, JUST ADD EXTRA CALCULATED COLUMNS 

-- USING GROUP BY

SELECT REGION, SUM(AMOUNT)
FROM SALES
GROUP BY REGION;

-- USING WINDOW FUNCTION

SELECT REGION,EMPLOYEE,AMOUNT,
        SUM(AMOUNT) OVER(PARTITION BY REGION
						ORDER BY AMOUNT DESC) AS TOTAL_REGION_SALES
FROM SALES; 


-- Q1. FIND THE TOP -02 HIGHEST SALES PER REGION USING WINDOW FUNCTION VIA CTE 
WITH RankedSales AS (
    SELECT 
        region,
        amount,
        ROW_NUMBER() OVER (PARTITION BY region ORDER BY amount DESC) AS rn
    FROM Sales
)
SELECT 
    region,
    amount
FROM RankedSales
WHERE rn <= 2
ORDER BY region, amount DESC;
 
-- Q2. DIFFERENTIATE BETWEEN ROW_NUMBER(), RANK, DENSE_RANK PROVIDED DUPLICATE EXISTS
-- Q3. COMPUTE 03 DAY MOVING AVERAGE OF THE SALE (CONSIDER ONLY PRECEDING DATES)
-- Q4. FIND THE DIFFERENCE IN SALES COMPARED TO THE PREVIOUS DAY FOR EACH EMPLOYEE [TIME BASED ANALYSIS]
 

-- IMPLEMENTING QUERY OPTIMIZATION
EXPLAIN SELECT *
FROM CUSTOMERS;

-- ADDING AN INDEX TO IMPROVIZE THE PERFORMANCE

-- SYNTAX CREATE INDEX IDX_CATEGORY ON TABLE_NAME(CATEGORY)

CREATE INDEX idx_category ON PRODUCTS(NAME);

-- RUN THE EXPLAIN STATEMENT AGAIN TO SEE HOW THE QUERY EXECUTION PLAN HAS IMPROVIZED

EXPLAIN SELECT NAME,UNIT_PRICE
FROM PRODUCTS 
WHERE NAME = 'Brocolinni - Gaylan, Chinese';


-- DATA VERIFICATION

USE E-COMMERCE_TABLE_NORMALIZE;
-- CHECKING MISSING DATA
-- CHECK THE MISSING VALUES IN THE PRODUCTS TABLE                      